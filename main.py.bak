import customtkinter as ctk
from tkinter import filedialog, messagebox, simpledialog
import torch
import torchaudio
from pydub import AudioSegment
from pydub.playback import play
import noisereduce as nr
import threading
import os
import csv
from io import BytesIO
import numpy as np
import re

# --- H·∫±ng s·ªë v√† gi√° tr·ªã m·∫∑c ƒë·ªãnh ---
class AppConfig:
    VAD_THRESHOLD = 0.4
    VAD_MIN_SILENCE_MS = 500
    VAD_MIN_SPEECH_MS = 450
    VAD_SPEECH_PAD_MS = 300
    EXPORT_SAMPLE_RATE = 24000
    EXPORT_CHANNELS = 1
    WAVS_DIR = "wavs"
    METADATA_FILE = "metadata.csv"

# --- T·∫£i m√¥ h√¨nh Silero VAD ---
def load_vad_model():
    try:
        model, utils = torch.hub.load(repo_or_dir='snakers4/silero-vad', model='silero_vad', force_reload=False, onnx=True)
        (get_speech_timestamps, _, read_audio, _, _) = utils
        return model, get_speech_timestamps, read_audio
    except Exception as e:
        messagebox.showerror("L·ªói t·∫£i m√¥ h√¨nh", f"Kh√¥ng th·ªÉ t·∫£i m√¥ h√¨nh Silero VAD...\nL·ªói: {e}")
        return None, None, None

class AudioProcessorApp(ctk.CTk):
    def __init__(self, model, get_speech_timestamps, read_audio):
        super().__init__()

        self.project_dir = os.path.dirname(os.path.abspath(__file__))
        self.wavs_dir_path = os.path.join(self.project_dir, AppConfig.WAVS_DIR)
        self.metadata_path = os.path.join(self.project_dir, AppConfig.METADATA_FILE)
        os.makedirs(self.wavs_dir_path, exist_ok=True)

        self.audio_file_path = None
        self.current_speaker = None
        self.audio_segments_data = []
        
        self.vad_model, self.get_speech_timestamps, self.read_audio = model, get_speech_timestamps, read_audio
        self.title("Tr√¨nh qu·∫£n l√Ω Dataset TTS")
        self.geometry("1100x800")
        ctk.set_appearance_mode("Dark")
        ctk.set_default_color_theme("blue")
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(3, weight=1)

        # --- Giao di·ªán ng∆∞·ªùi d√πng ---
        self.setup_frame = ctk.CTkFrame(self)
        self.setup_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        self.setup_frame.grid_columnconfigure(1, weight=1)

        ctk.CTkLabel(self.setup_frame, text="B∆∞·ªõc 1:", font=ctk.CTkFont(weight="bold")).grid(row=0, column=0, padx=(10,0), pady=10, sticky="w")
        self.select_button = ctk.CTkButton(self.setup_frame, text="Ch·ªçn file Audio ngu·ªìn", command=self.select_audio_file)
        self.select_button.grid(row=0, column=1, padx=10, pady=10, sticky="w")
        self.file_label = ctk.CTkLabel(self.setup_frame, text="Ch∆∞a ch·ªçn file", anchor="w")
        self.file_label.grid(row=0, column=2, padx=10, pady=10, sticky="ew")

        ctk.CTkLabel(self.setup_frame, text="B∆∞·ªõc 2:", font=ctk.CTkFont(weight="bold")).grid(row=1, column=0, padx=(10,0), pady=10, sticky="w")
        self.speaker_selector = ctk.CTkComboBox(self.setup_frame, command=self.load_speaker_session)
        self.speaker_selector.grid(row=1, column=1, padx=10, pady=10, sticky="w")
        self.new_speaker_button = ctk.CTkButton(self.setup_frame, text="T·∫°o ng∆∞·ªùi n√≥i m·ªõi", width=140, command=self.create_new_speaker)
        self.new_speaker_button.grid(row=1, column=2, padx=10, pady=10, sticky="w")
        
        self.params_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.params_frame.grid(row=1, column=0, padx=10, pady=0, sticky="ew")
        self.vad_params = {}
        params_to_show = {
            'threshold': ("Ng∆∞·ª°ng", AppConfig.VAD_THRESHOLD), 'min_silence_duration_ms': ("Kho·∫£ng l·∫∑ng", AppConfig.VAD_MIN_SILENCE_MS),
            'min_speech_duration_ms': ("Gi·ªçng n√≥i", AppConfig.VAD_MIN_SPEECH_MS), 'speech_pad_ms': ("V√πng ƒë·ªám", AppConfig.VAD_SPEECH_PAD_MS)
        }
        for i, (key, (label, value)) in enumerate(params_to_show.items()):
            ctk.CTkLabel(self.params_frame, text=f"{label} (ms):").grid(row=0, column=i*2, padx=(10, 5), pady=5)
            entry = ctk.CTkEntry(self.params_frame, width=80)
            entry.insert(0, str(value))
            entry.grid(row=0, column=i*2+1, padx=(0, 20), pady=5)
            self.vad_params[key] = entry
        
        self.control_frame = ctk.CTkFrame(self)
        self.control_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew")
        self.process_button = ctk.CTkButton(self.control_frame, text="3. X·ª≠ l√Ω & Th√™m Audio", command=self.start_processing_thread, state="disabled")
        self.process_button.pack(side="left", padx=10, pady=10)
        self.noise_reduce_checkbox = ctk.CTkCheckBox(self.control_frame, text="√Åp d·ª•ng Kh·ª≠ nhi·ªÖu")
        self.noise_reduce_checkbox.pack(side="left", padx=10, pady=10)
        
        self.status_label = ctk.CTkLabel(self.control_frame, text="Ch√†o m·ª´ng!")
        self.status_label.pack(side="left", padx=10, pady=10, expand=True, fill="x")
        
        self.scrollable_frame = ctk.CTkScrollableFrame(self, label_text="Danh s√°ch Audio")
        self.scrollable_frame.grid(row=3, column=0, padx=10, pady=10, sticky="nsew")
        self.scrollable_frame.grid_columnconfigure(0, weight=1)

        self.bottom_frame = ctk.CTkFrame(self)
        self.bottom_frame.grid(row=4, column=0, padx=10, pady=10, sticky="ew")
        self.clear_all_button = ctk.CTkButton(self.bottom_frame, text="X√≥a c√°c file c·ªßa ng∆∞·ªùi n√≥i n√†y", command=self.clear_speaker_directory, hover_color="#C82333", state="disabled")
        self.clear_all_button.pack(side="left", padx=10, pady=10)
        self.save_metadata_button = ctk.CTkButton(self.bottom_frame, text="4. L∆∞u t·∫•t c·∫£ thay ƒë·ªïi", command=self.save_metadata, state="disabled")
        self.save_metadata_button.pack(side="right", padx=10, pady=10)

        self.update_speaker_list()

    def update_speaker_list(self):
        try:
            speakers = [d for d in os.listdir(self.wavs_dir_path) if os.path.isdir(os.path.join(self.wavs_dir_path, d))]
            self.speaker_selector.configure(values=speakers if speakers else ["Kh√¥ng c√≥ ng∆∞·ªùi n√≥i n√†o"])
            if speakers:
                self.speaker_selector.set(speakers[0])
                self.load_speaker_session(speakers[0])
            else:
                self.speaker_selector.set("")
        except Exception as e:
            print(f"L·ªói khi c·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi n√≥i: {e}")

    def create_new_speaker(self):
        speaker_name = simpledialog.askstring("T·∫°o ng∆∞·ªùi n√≥i m·ªõi", "Nh·∫≠p t√™n cho ng∆∞·ªùi n√≥i m·ªõi (v√≠ d·ª•: speaker_03):")
        if speaker_name and speaker_name.strip():
            speaker_name = speaker_name.strip()
            new_speaker_path = os.path.join(self.wavs_dir_path, speaker_name)
            if not os.path.exists(new_speaker_path):
                os.makedirs(new_speaker_path)
                messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ t·∫°o th∆∞ m·ª•c cho ng∆∞·ªùi n√≥i: {speaker_name}")
                self.update_speaker_list()
                self.speaker_selector.set(speaker_name)
            else:
                messagebox.showwarning("T·ªìn t·∫°i", "Ng∆∞·ªùi n√≥i n√†y ƒë√£ t·ªìn t·∫°i.")
                self.speaker_selector.set(speaker_name)
        self.load_speaker_session(speaker_name)

    def load_speaker_session(self, speaker_name):
        if not speaker_name or speaker_name == "Kh√¥ng c√≥ ng∆∞·ªùi n√≥i n√†o":
            self.clear_ui_list()
            self.process_button.configure(state="disabled")
            self.clear_all_button.configure(state="disabled")
            self.current_speaker = None
            return
            
        self.current_speaker = speaker_name
        self.clear_ui_list()
        self.clear_all_button.configure(state="normal")
        if self.audio_file_path:
            self.process_button.configure(state="normal")

        all_metadata = []
        if os.path.isfile(self.metadata_path):
            with open(self.metadata_path, 'r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                all_metadata = list(reader)

        expected_parent_dir = os.path.join(AppConfig.WAVS_DIR, self.current_speaker).replace("\\", "/")
        
        loaded_segments = []
        for row in all_metadata:
            try:
                # L·∫•y th∆∞ m·ª•c cha t·ª´ ƒë∆∞·ªùng d·∫´n trong file CSV
                # os.path.dirname ho·∫°t ƒë·ªông t·ªët v·ªõi c·∫£ '/' v√† '\'
                file_parent_dir = os.path.dirname(row['audio_filename']).replace("\\", "/")
                
                if file_parent_dir == expected_parent_dir:
                    full_path = os.path.join(self.project_dir, row['audio_filename'].replace("/", os.path.sep))
                    
                    if os.path.exists(full_path):
                        duration = 0.0
                        try:
                            # L·∫•y th·ªùi l∆∞·ª£ng th·ª±c t·∫ø c·ªßa file
                            audio = AudioSegment.from_file(full_path)
                            duration = len(audio) / 1000.0
                        except Exception as e:
                            print(f"Kh√¥ng th·ªÉ ƒë·ªçc file audio ƒë·ªÉ l·∫•y duration: {full_path}, l·ªói: {e}")

                        # T√°ch s·ªë ID t·ª´ t√™n file ƒë·ªÉ s·∫Øp x·∫øp
                        file_id_match = re.search(r'_(\d+)\.wav$', os.path.basename(full_path))
                        file_id = int(file_id_match.group(1)) if file_id_match else -1
                        
                        loaded_segments.append({
                            'id': file_id,
                            'path': full_path,
                            'duration': duration,
                            'transcript': row['transcript']
                        })
            except (KeyError, IndexError) as e:
                print(f"B·ªè qua d√≤ng l·ªói trong CSV: {row}, l·ªói: {e}")
                continue

        self.audio_segments_data = loaded_segments
        self.status_label.configure(text=f"ƒê√£ t·∫£i {len(loaded_segments)} file c·ªßa ng∆∞·ªùi n√≥i: {self.current_speaker}")
        self.update_ui_with_segments()

    def select_audio_file(self):
        filepath = filedialog.askopenfilename(title="B∆∞·ªõc 1: Ch·ªçn m·ªôt file audio", filetypes=(("Audio Files", "*.wav *.mp3 *.flac *.m4a"), ("All files", "*.*")))
        if filepath:
            self.audio_file_path = filepath
            self.file_label.configure(text=os.path.basename(filepath))
            if self.current_speaker: self.process_button.configure(state="normal")

    def clear_ui_list(self):
        for widget in self.scrollable_frame.winfo_children(): widget.destroy()
        self.audio_segments_data = []
        self.save_metadata_button.configure(state="disabled")

    def start_processing_thread(self):
        if not self.audio_file_path or not self.current_speaker:
            messagebox.showwarning("Thi·∫øu th√¥ng tin", "Vui l√≤ng ch·ªçn file audio v√† m·ªôt ng∆∞·ªùi n√≥i tr∆∞·ªõc.")
            return
        try:
            self.current_vad_params = { key: float(entry.get()) for key, entry in self.vad_params.items() }
            # ... (ph·∫ßn x√°c th·ª±c tham s·ªë) ...
        except ValueError:
            messagebox.showerror("L·ªói tham s·ªë", "C√°c tham s·ªë VAD ph·∫£i l√† s·ªë.")
            return
        
        # V√¥ hi·ªáu h√≥a c√°c n√∫t ƒë·ªÉ tr√°nh xung ƒë·ªôt
        self.process_button.configure(state="disabled")
        self.status_label.configure(text=f"ƒêang x·ª≠ l√Ω cho {self.current_speaker}, vui l√≤ng ch·ªù...")
        
        thread = threading.Thread(target=self.process_and_save_audio)
        thread.start()

    def get_start_index(self, speaker_path):
        start_index = 1
        try:
            pattern = re.compile(f"audio_(\d+)\.wav$")
            existing_indices = []
            for filename in os.listdir(speaker_path):
                match = pattern.match(filename)
                if match:
                    existing_indices.append(int(match.group(1)))
            if existing_indices:
                start_index = max(existing_indices) + 1
        except Exception as e:
            print(f"L·ªói khi qu√©t th∆∞ m·ª•c: {e}")
        return start_index

    def process_and_save_audio(self):
        newly_created_segments = []
        try:
            speaker_path = os.path.join(self.wavs_dir_path, self.current_speaker)
            start_index = self.get_start_index(speaker_path)
            
            main_audio = AudioSegment.from_file(self.audio_file_path)
            # ... (ph·∫ßn x·ª≠ l√Ω VAD) ...
            wav_tensor = self.read_audio(BytesIO(main_audio.export(format="wav").read()), sampling_rate=16000)
            speech_timestamps = self.get_speech_timestamps(wav_tensor, self.vad_model, sampling_rate=16000, **self.current_vad_params)
            
            for i, ts in enumerate(speech_timestamps):
                segment = main_audio[ts['start']*1000/16000 : ts['end']*1000/16000]
                samples_int = np.array(segment.get_array_of_samples())
                
                if self.noise_reduce_checkbox.get():
                    reduced_float = nr.reduce_noise(y=samples_int, sr=segment.frame_rate)
                    samples_for_export = (reduced_float * 32767).astype(np.int16)
                else:
                    samples_for_export = samples_int

                processed_segment = AudioSegment(samples_for_export.tobytes(), sample_width=2, frame_rate=segment.frame_rate, channels=segment.channels)
                final_segment = processed_segment.set_frame_rate(AppConfig.EXPORT_SAMPLE_RATE).set_channels(AppConfig.EXPORT_CHANNELS)
                
                filename = f"audio_{start_index + i:03d}.wav"
                export_path = os.path.join(speaker_path, filename)
                final_segment.export(export_path, format="wav")
                
                new_segment_data = {
                    'path': export_path, 'duration': len(final_segment) / 1000.0,
                    'transcript': '' # Transcript m·ªõi lu√¥n r·ªóng
                }
                newly_created_segments.append(new_segment_data)

            # Th√™m c√°c segment m·ªõi v√†o danh s√°ch t·ªïng
            self.audio_segments_data.extend(newly_created_segments)
            self.after(0, self.update_ui_with_segments)

        except Exception as e:
            error_msg = f"ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh x·ª≠ l√Ω:\n{e}"
            self.after(0, lambda: messagebox.showerror("L·ªói x·ª≠ l√Ω", error_msg))
        finally:
            self.after(0, self.processing_finished, len(newly_created_segments))

    def update_ui_with_segments(self):
        for widget in self.scrollable_frame.winfo_children(): widget.destroy()
        if not self.audio_segments_data: return
        
        sorted_segments = sorted(self.audio_segments_data, key=lambda x: x['path'])
        
        for i, segment_data in enumerate(sorted_segments):
            # ... (ph·∫ßn v·∫Ω UI nh∆∞ tr∆∞·ªõc)
            segment_frame = ctk.CTkFrame(self.scrollable_frame)
            segment_frame.grid(row=i, column=0, padx=5, pady=5, sticky="ew")
            segment_frame.grid_columnconfigure(2, weight=1)

            info_text = f"{os.path.basename(segment_data['path'])} ({segment_data['duration']:.2f}s)"
            ctk.CTkLabel(segment_frame, text=info_text, width=150).grid(row=0, column=0, padx=5, pady=5)
            
            ctk.CTkButton(segment_frame, text="‚ñ∂ Play", width=80, command=lambda path=segment_data['path']: threading.Thread(target=self.play_audio_file, args=(path,), daemon=True).start()).grid(row=0, column=1, padx=5, pady=5)
            
            entry = ctk.CTkEntry(segment_frame, placeholder_text="Nh·∫≠p transcript t·∫°i ƒë√¢y...")
            entry.grid(row=0, column=2, padx=5, pady=5, sticky="ew")
            if 'transcript' in segment_data: entry.insert(0, segment_data['transcript'])
            
            ctk.CTkButton(segment_frame, text="üóëÔ∏è", width=30, fg_color="transparent", hover_color="#C82333", command=lambda data=segment_data: self.delete_segment(data)).grid(row=0, column=3, padx=5, pady=5)

            segment_data.update({'ui_frame': segment_frame, 'entry_widget': entry})
        
        self.save_metadata_button.configure(state="normal")


    def processing_finished(self, count):
        self.status_label.configure(text=f"Ho√†n t·∫•t! ƒê√£ th√™m {count} file m·ªõi cho {self.current_speaker}.")
        self.process_button.configure(state="normal")
        self.select_button.configure(state="normal")

    def play_audio_file(self, file_path):
        try:
            play(AudioSegment.from_file(file_path))
        except Exception as e:
            print(f"L·ªói khi ph√°t file {os.path.basename(file_path)}: {e}")

    def delete_segment(self, segment_data):
        if messagebox.askyesno("X√°c nh·∫≠n X√≥a", f"B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a vƒ©nh vi·ªÖn file:\n{os.path.basename(segment_data['path'])}?"):
            try:
                os.remove(segment_data['path'])
                segment_data['ui_frame'].destroy()
                self.audio_segments_data.remove(segment_data)
                self.status_label.configure(text=f"ƒê√£ x√≥a file {os.path.basename(segment_data['path'])}.")
            except Exception as e: messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ x√≥a file: {e}")
            
    def save_metadata(self):
        all_metadata = []
        if os.path.isfile(self.metadata_path):
            with open(self.metadata_path, 'r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    # Gi·ªØ l·∫°i d·ªØ li·ªáu c·ªßa nh·ªØng ng∆∞·ªùi n√≥i kh√°c
                    if not row['audio_filename'].startswith(os.path.join(AppConfig.WAVS_DIR, self.current_speaker).replace("\\", "/") + "/"):
                        all_metadata.append(row)

        # Th√™m d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t c·ªßa ng∆∞·ªùi n√≥i hi·ªán t·∫°i
        for segment_data in self.audio_segments_data:
            relative_path = os.path.join(AppConfig.WAVS_DIR, self.current_speaker, os.path.basename(segment_data['path'])).replace("\\", "/")
            transcript = segment_data['entry_widget'].get().lower()
            if transcript:
                all_metadata.append({'audio_filename': relative_path, 'transcript': transcript})
        
        try:
            # S·∫Øp x·∫øp l·∫°i to√†n b·ªô d·ªØ li·ªáu v√† ghi ƒë√® file
            sorted_metadata = sorted(all_metadata, key=lambda x: x['audio_filename'])
            with open(self.metadata_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=['audio_filename', 'transcript'])
                writer.writeheader()
                writer.writerows(sorted_metadata)
            messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u t·∫•t c·∫£ thay ƒë·ªïi v√†o metadata.csv")
            self.status_label.configure(text="ƒê√£ l∆∞u. S·∫µn s√†ng cho t√°c v·ª• ti·∫øp theo.")
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ ghi file CSV: {e}")

    def clear_speaker_directory(self):
        if not self.current_speaker:
            messagebox.showinfo("Th√¥ng b√°o", "Vui l√≤ng ch·ªçn m·ªôt ng∆∞·ªùi n√≥i tr∆∞·ªõc.")
            return
        
        speaker_path = os.path.join(self.wavs_dir_path, self.current_speaker)
        warning_message = f"C·∫¢NH B√ÅO!\nH√†nh ƒë·ªông n√†y s·∫Ω X√ìA T·∫§T C·∫¢ c√°c file .wav trong th∆∞ m·ª•c c·ªßa ng∆∞·ªùi n√≥i '{self.current_speaker}'.\n\nƒê∆∞·ªùng d·∫´n: {speaker_path}\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c. B·∫°n c√≥ ch·∫Øc ch·∫Øn kh√¥ng?"
        
        if messagebox.askyesno("X√ÅC NH·∫¨N X√ìA", warning_message):
            files_deleted_count = 0
            try:
                for filename in os.listdir(speaker_path):
                    if filename.endswith('.wav'):
                        os.remove(os.path.join(speaker_path, filename))
                        files_deleted_count += 1
                
                # Sau khi x√≥a file, t·∫£i l·∫°i session (s·∫Ω th·∫•y danh s√°ch r·ªóng)
                self.load_speaker_session(self.current_speaker)
                messagebox.showinfo("Ho√†n t·∫•t", f"ƒê√£ x√≥a th√†nh c√¥ng {files_deleted_count} file audio c·ªßa {self.current_speaker}.")
                self.status_label.configure(text=f"ƒê√£ x√≥a s·∫°ch th∆∞ m·ª•c c·ªßa {self.current_speaker}.")
            except Exception as e:
                messagebox.showerror("L·ªói", f"ƒê√£ x·∫£y ra l·ªói khi d·ªçn d·∫πp th∆∞ m·ª•c: {e}")

if __name__ == "__main__":
    print("ƒêang t·∫£i m√¥ h√¨nh Silero VAD, vui l√≤ng ch·ªù...")
    model, get_speech_timestamps, read_audio = load_vad_model()
    if model:
        print("T·∫£i m√¥ h√¨nh th√†nh c√¥ng. ƒêang kh·ªüi ƒë·ªông ·ª©ng d·ª•ng...")
        app = AudioProcessorApp(model, get_speech_timestamps, read_audio)
        app.mainloop()
    else:
        print("Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông ·ª©ng d·ª•ng do l·ªói t·∫£i m√¥ h√¨nh.")
